package de.l3s.interweb.core.chat;

import java.io.IOException;
import java.io.Serial;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.databind.*;

import jakarta.validation.constraints.NotEmpty;

import io.quarkus.runtime.annotations.RegisterForReflection;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;

@RegisterForReflection
public class CallFunction implements Serializable {
    @Serial
    private static final long serialVersionUID = -2780720621585498099L;

    /**
     * The name of the function to call.
     */
    @NotEmpty
    private String name;

    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON,
     * and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     */
    @JsonDeserialize(using = ArgumentsDeserializer.class)
    private Map<String, String> arguments;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setArguments(Map<String, String> arguments) {
        this.arguments = arguments;
    }

    public Map<String, String> getArguments() {
        return arguments;
    }

    public static class ArgumentsDeserializer extends StdDeserializer<Map<String, String>> {

        public ArgumentsDeserializer() {
            this(null);
        }

        public ArgumentsDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public Map<String, String> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JavaType typeRef = ctxt.getTypeFactory().constructMapType(HashMap.class, String.class, String.class);

            JsonNode node = jp.getCodec().readTree(jp);
            if (node.isTextual()) {
                try {
                    return new ObjectMapper().readValue(node.asText(), typeRef);
                } catch (JsonProcessingException e) {
                    throw new RuntimeException(e);
                }
            }

            return ctxt.readTreeAsValue(node, typeRef);
        }
    }
}
